<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>burak.wtf — ouroboros</title>
<meta name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<style>
  html, body { margin:0; padding:0; height:100%; background:#fff; }
  body {
    display:flex; align-items:center; justify-content:center;
    font-family: Helvetica, Arial, sans-serif;
    min-height: -webkit-fill-available;
    background:#fff;
  }
  .stage {
    position: fixed; inset: 0;
    width: 100vw; height: 100dvh;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background:#fff;
  }
  .note {
    position: fixed; left:50%; bottom: calc(env(safe-area-inset-bottom) + 12px);
    transform: translateX(-50%);
    font-size: 14px; color:#000; text-align:center; user-select:none;
    mix-blend-mode: multiply;
  }
  /* ——— Mail butonu: beyaz ——— */
  .mail-button {
    position: fixed;
    left: auto; top: auto; right: 20px; bottom: 20px; /* ilk konum */
    width: 56px; height: 56px;
    display: grid; place-items: center;
    text-decoration: none;
    background: #fff;
    color: #000;
    border-radius: 50%;
    box-shadow: 0 6px 16px rgba(0,0,0,0.18);
    border: 1px solid rgba(0,0,0,0.15);
    transition: transform .15s;
    touch-action: none; /* sürükleme için */
    user-select: none;
  }
  .mail-button:hover { transform: scale(1.06); }
  .mail-button svg { width: 26px; height: 26px; display:block; }
  canvas { display:block; }
</style>
</head>
<body>
  <div id="stage" class="stage"></div>
  <div class="note">
    drag: tilt • pinch/scroll: zoom • Space: auto-orbit • Z: reset zoom
  </div>

  <!-- Beyaz, fırlatılabilir mail tuşu -->
  <a id="mailBtn" href="mailto:burakaltiparmak@icloud.com" class="mail-button" aria-label="Send email">
   
  </a>

<script type="module">
/* ===== Three.js sahnesi — minimal doğal, beyaz ouroboros ===== */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const stage = document.getElementById('stage');

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
stage.appendChild(renderer.domElement);

// Scene & Camera
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
scene.add(camera);
let zoom = 1, MIN_ZOOM = 0.35, MAX_ZOOM = 4;
const baseCamZ = 3.2;
camera.position.set(0, 0, baseCamZ);

// Lights — beyaz objeyi okumak için yumuşak ışık
const hemi = new THREE.HemisphereLight(0xffffff, 0xeaeaea, 0.95);
scene.add(hemi);
const key = new THREE.DirectionalLight(0xffffff, 0.9);
key.position.set(2.5, 3.5, 2.2);
scene.add(key);
const rim = new THREE.DirectionalLight(0xffffff, 0.5);
rim.position.set(-3.0, 1.5, -2.5);
scene.add(rim);

// Procedural “pul” dokusu — çok hafif, beyaza uygun
function makeScaleTexture(size=1024){
  const cnv = document.createElement('canvas');
  cnv.width = cnv.height = size;
  const ctx = cnv.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,size,size);

  const lg = ctx.createLinearGradient(0,0,size,0);
  lg.addColorStop(0, '#ffffff');
  lg.addColorStop(0.5, '#f6f6f6');
  lg.addColorStop(1, '#ffffff');
  ctx.fillStyle = lg;
  ctx.fillRect(0,0,size,size);

  ctx.strokeStyle = 'rgba(0,0,0,0.12)';   /* önce 0.22 idi, beyaz için incelttik */
  ctx.lineWidth = size*0.0019;
  const rows = 80, cols = 160;
  for (let r=0; r<=rows; r++){
    const y = (r/rows) * size;
    for (let c=0; c<=cols; c++){
      const x = (c/cols) * size;
      const w = size/cols, h = size/rows;
      ctx.beginPath();
      ctx.moveTo(x - w*0.48, y);
      ctx.quadraticCurveTo(x, y - h*0.45, x + w*0.48, y);
      ctx.quadraticCurveTo(x, y + h*0.45, x - w*0.48, y);
      ctx.stroke();
    }
  }

  // çok ince sırt hissi
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let i=0;i<80;i++){
    const t = i/80;
    const cx = t*size, cy = size*0.08;
    const w = size*0.018, h = size*0.06;
    ctx.beginPath();
    ctx.moveTo(cx, cy - h*0.5);
    ctx.lineTo(cx + w*0.8, cy + h*0.5);
    ctx.lineTo(cx - w*0.8, cy + h*0.5);
    ctx.closePath();
    ctx.fill();
  }

  const tex = new THREE.CanvasTexture(cnv);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2.5, 1.0);
  return tex;
}
const scaleTex = makeScaleTexture();

// Ouroboros geometri
class TaperedTorusGeometry extends THREE.BufferGeometry {
  constructor(R=1.0, r=0.24, radialSeg=512, tubularSeg=256, taper=0.12){
    super();
    const verts=[], norms=[], uvs=[];
    for (let i=0;i<=radialSeg;i++){
      const u = i/radialSeg * Math.PI*2;
      const cosu=Math.cos(u), sinu=Math.sin(u);
      const rLocal = r * (1 - taper*0.6 + taper*Math.sin(u*2)*0.5);
      for (let j=0;j<=tubularSeg;j++){
        const v = j/tubularSeg * Math.PI*2;
        const cosv=Math.cos(v), sinv=Math.sin(v);
        const cx=(R + rLocal*cosv)*cosu;
        const cy=(R + rLocal*cosv)*sinu;
        const cz= rLocal*sinv;
        verts.push(cx,cy,cz);
        norms.push(cosu*cosv, sinu*cosv, sinv);
        uvs.push(i/radialSeg, j/tubularSeg);
      }
    }
    const idx=[];
    for (let i=0;i<radialSeg;i++){
      for (let j=0;j<tubularSeg;j++){
        const a=(tubularSeg+1)*i+j, b=(tubularSeg+1)*(i+1)+j;
        idx.push(a,b,a+1, a+1,b,b+1);
      }
    }
    this.setIndex(idx);
    this.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
    this.setAttribute('normal',   new THREE.Float32BufferAttribute(norms,3));
    this.setAttribute('uv',       new THREE.Float32BufferAttribute(uvs,2));
    this.computeBoundingSphere();
  }
}

const geo = new TaperedTorusGeometry(1.0, 0.24, 720, 240, 0.18);
const mat = new THREE.MeshStandardMaterial({
  map: scaleTex,
  metalness: 0.05,
  roughness: 0.72,
  color: 0xffffff,          // beyaz
});
const ouro = new THREE.Mesh(geo, mat);
scene.add(ouro);

// Ağız-kuyruk birleşimi için hafif gölge halka
{
  const ring = new THREE.RingGeometry(1.0-0.24*0.985, 1.0+0.24*0.985, 256);
  const m = new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.07, side:THREE.DoubleSide });
  const seam = new THREE.Mesh(ring, m);
  seam.rotation.x = Math.PI/2;
  scene.add(seam);
}

/* ===== Etkileşim (aynı kısayollar) ===== */
let pitch = -0.05, yaw = 0.4;
let autoOrbit = false;
const ORBIT_YAW_SPEED = 0.25;
const ORBIT_PITCH_SPEED = 0.10;
const KEY_TILT_STEP = 0.07;

let dragging=false, lastX=0, lastY=0;
let velYaw=0, velPitch=0;
let inertiaActive=false, inertiaProfile='average';
const INERTIA_DECAY = { slow:1.6, average:2.8, fast:4.5 };
const EPS = 1e-4;

function setObjectTransform(){ ouro.rotation.set(pitch, yaw, 0); }
setObjectTransform();

addEventListener('keydown', e=>{
  if (e.key==='ArrowUp')   { pitch -= KEY_TILT_STEP; setObjectTransform(); }
  if (e.key==='ArrowDown') { pitch += KEY_TILT_STEP; setObjectTransform(); }
  if (e.key==='ArrowLeft') { yaw   -= KEY_TILT_STEP; setObjectTransform(); }
  if (e.key==='ArrowRight'){ yaw   += KEY_TILT_STEP; setObjectTransform(); }
  if (e.code==='Space'){ autoOrbit=!autoOrbit; e.preventDefault(); }
  if (e.key.toLowerCase()==='s') inertiaProfile='slow';
  if (e.key.toLowerCase()==='a') inertiaProfile='average';
  if (e.key.toLowerCase()==='f') inertiaProfile='fast';
  if (e.key.toLowerCase()==='z'){ zoom=1; camera.position.z = baseCamZ; }
});

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// Zoom: wheel & pinch
stage.addEventListener('wheel', ev=>{
  const scale = Math.exp(-ev.deltaY * 0.001);
  zoom = clamp(zoom * scale, MIN_ZOOM, MAX_ZOOM);
  camera.position.z = baseCamZ / zoom;
  ev.preventDefault();
}, {passive:false});

// Pointer drag + momentum (3D)
let lastSamples=[];
function nowMs(){ return performance.now(); }
function pushSample(x,y,ts){
  lastSamples.push({x,y,ts});
  const cutoff = ts - 80;
  while (lastSamples.length && lastSamples[0].ts < cutoff) lastSamples.shift();
}

function onPointerDown(ev){
  try{ stage.setPointerCapture(ev.pointerId);}catch{}
  activePointers.set(ev.pointerId, {x:ev.clientX, y:ev.clientY});
  if (activePointers.size < 2){
    dragging=true; inertiaActive=false;
    lastX=ev.clientX; lastY=ev.clientY; lastSamples=[];
    pushSample(lastX,lastY,nowMs());
  }
  ev.preventDefault();
}

function onPointerMove(ev){
  if (activePointers.has(ev.pointerId)){
    activePointers.set(ev.pointerId, {x:ev.clientX, y:ev.clientY});
  }
  if (pinching){ handlePinchUpdate(); ev.preventDefault(); return; }
  if (!dragging) return;

  const x=ev.clientX, y=ev.clientY;
  const dx=x-lastX, dy=y-lastY;
  const ts=nowMs();

  const kx = 2*Math.PI / innerHeight;
  const ky = 2*Math.PI / innerWidth;

  const dPitch = -dy * kx * 0.25;
  const dYaw   =  dx * ky * 0.25;

  pitch += dPitch; yaw += dYaw; setObjectTransform();

  const prevTs = lastSamples.at(-1)?.ts ?? ts;
  const dt = Math.max((ts - prevTs)/1000, 1/240);
  velPitch = dPitch/dt; velYaw = dYaw/dt;

  lastX=x; lastY=y; pushSample(x,y,ts);
  ev.preventDefault();
}

function onPointerUp(ev){
  if (activePointers.has(ev.pointerId)) activePointers.delete(ev.pointerId);
  if (pinching && activePointers.size<2){ pinching=false; baseZoom=zoom; }
  if (!dragging) return;
  dragging=false;

  const first=lastSamples[0], last=lastSamples.at(-1);
  if (first && last && last.ts>first.ts){
    const dx=last.x-first.x, dy=last.y-first.y, dt=(last.ts-first.ts)/1000;
    const kx=2*Math.PI/innerHeight, ky=2*Math.PI/innerWidth;
    velPitch=(-dy*kx*0.25)/dt; velYaw=(dx*ky*0.25)/dt;
  }
  inertiaActive=true;
  try{ stage.releasePointerCapture(ev.pointerId);}catch{}
  ev.preventDefault();
}

stage.addEventListener('pointerdown', onPointerDown, {passive:false});
stage.addEventListener('pointermove', onPointerMove, {passive:false});
stage.addEventListener('pointerup',   onPointerUp,   {passive:false});
stage.addEventListener('pointercancel', onPointerUp, {passive:false});

// Pinch (iki parmak)
const activePointers = new Map();
let pinching=false, startDist=0, baseZoom=zoom;
function distance(pA,pB){ const dx=pA.x-pB.x, dy=pA.y-pB.y; return Math.hypot(dx,dy); }
function handlePinchUpdate(){
  if (activePointers.size<2) return;
  const pts=[...activePointers.values()];
  const d=distance(pts[0],pts[1]);
  if (!pinching){
    pinching=true; startDist=d||1; baseZoom=zoom; dragging=false; inertiaActive=false; return;
  }
  const factor = d / (startDist||1);
  zoom = clamp(baseZoom*factor, MIN_ZOOM, MAX_ZOOM);
  camera.position.z = baseCamZ / zoom;
}
window.addEventListener('gesturestart', e=>{ baseZoom=zoom; e.preventDefault(); }, {passive:false});
window.addEventListener('gesturechange', e=>{
  zoom = clamp(baseZoom*e.scale, MIN_ZOOM, MAX_ZOOM);
  camera.position.z = baseCamZ / zoom; e.preventDefault();
},{passive:false});
window.addEventListener('gestureend', e=>{ e.preventDefault(); }, {passive:false});

/* ===== Döngü ===== */
let lastTs = performance.now();
function tick(ts){
  const dt=(ts-lastTs)/1000; lastTs=ts;

  if (autoOrbit){
    yaw   += ORBIT_YAW_SPEED   * dt;
    pitch += ORBIT_PITCH_SPEED * dt;
    setObjectTransform();
  }

  if (inertiaActive && !dragging && !autoOrbit && !pinching){
    pitch += velPitch*dt; yaw += velYaw*dt; setObjectTransform();
    const lambda = INERTIA_DECAY[inertiaProfile] || INERTIA_DECAY.average;
    const decay = Math.exp(-lambda*dt);
    velPitch*=decay; velYaw*=decay;
    if (Math.abs(velYaw)<EPS && Math.abs(velPitch)<EPS){ inertiaActive=false; velYaw=velPitch=0; }
  }

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Resize
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* ===== Mail butonu: sürükle, fırlat, zıplat ===== */
const mailBtn = document.getElementById('mailBtn');

let mbDragging=false, mbStartX=0, mbStartY=0, mbLastX=0, mbLastY=0;
let mbVX=0, mbVY=0, mbMoving=false, mbWasDrag=false;
let mbLastT=0;
const MB_DECAY = 0.0015;          // sürtünme (ms başına)
const MB_BOUNCE = 0.65;           // kenardan sekme katsayısı
const CLICK_THRESH = 6;           // px (bundan az hareketse tık say)
const SAFE = { l:8, t:8, r:8, b:8 }; // kenar tamponları

function mbRect(){ return mailBtn.getBoundingClientRect(); }
function mbToLeftTop(){
  // right/bottom ile başladı; şimdi left/top'a geçir
  const r = mbRect();
  mailBtn.style.left = `${r.left}px`;
  mailBtn.style.top  = `${r.top}px`;
  mailBtn.style.right = 'auto';
  mailBtn.style.bottom= 'auto';
}

function mbPointerDown(e){
  mbToLeftTop();
  mbDragging=true; mbWasDrag=false; mbMoving=false;
  mbStartX=e.clientX; mbStartY=e.clientY;
  mbLastX=e.clientX; mbLastY=e.clientY; mbVX=0; mbVY=0; mbLastT=performance.now();
  mailBtn.style.transition='none';
  e.preventDefault();
}
function mbPointerMove(e){
  if(!mbDragging) return;
  const dx=e.clientX-mbLastX, dy=e.clientY-mbLastY;
  const now=performance.now(), dt=Math.max(now-mbLastT, 1);
  mbVX = dx/dt * 16.6;   // px/frame eşleniği
  mbVY = dy/dt * 16.6;
  mbLastT=now; mbLastX=e.clientX; mbLastY=e.clientY;

  const r = mbRect();
  const nx = r.left + dx, ny = r.top + dy;
  mailBtn.style.left = `${nx}px`;
  mailBtn.style.top  = `${ny}px`;

  if (!mbWasDrag && Math.hypot(e.clientX-mbStartX, e.clientY-mbStartY) > CLICK_THRESH) {
    mbWasDrag = true; // artık tık değil sürükleme
  }
  e.preventDefault();
}
function mbPointerUp(e){
  if(!mbDragging) return;
  mbDragging=false;

  if (!mbWasDrag) {
    // tık say: doğal <a> davranışı
    mailBtn.click();
    return;
  }
  mbMoving=true;
  requestAnimationFrame(mbStep);
  e.preventDefault();
}

function clampRange(v, min, max){ return Math.max(min, Math.min(max, v)); }
function mbStep(){
  if(!mbMoving) return;
  const r = mbRect();
  let x = r.left, y = r.top;
  x += mbVX; y += mbVY;

  // sürtünme
  const decay = Math.exp(-MB_DECAY * 16.6);
  mbVX *= decay; mbVY *= decay;

  // kenarlar
  const maxX = innerWidth  - r.width  - SAFE.r;
  const maxY = innerHeight - r.height - SAFE.b;
  const minX = SAFE.l, minY = SAFE.t;

  // yatay
  if (x < minX) { x = minX; mbVX = -mbVX * MB_BOUNCE; }
  if (x > maxX) { x = maxX; mbVX = -mbVX * MB_BOUNCE; }
  // dikey
  if (y < minY) { y = minY; mbVY = -mbVY * MB_BOUNCE; }
  if (y > maxY) { y = maxY; mbVY = -mbVY * MB_BOUNCE; }

  mailBtn.style.left = `${x}px`;
  mailBtn.style.top  = `${y}px`;

  if (Math.hypot(mbVX, mbVY) < 0.25) { mbMoving=false; return; }
  requestAnimationFrame(mbStep);
}

mailBtn.addEventListener('pointerdown', mbPointerDown, {passive:false});
window.addEventListener('pointermove', mbPointerMove, {passive:false});
window.addEventListener('pointerup',   mbPointerUp,   {passive:false});
window.addEventListener('pointercancel', mbPointerUp, {passive:false});

// Başlangıç yönü hazır
</script>
</body>
</html>
