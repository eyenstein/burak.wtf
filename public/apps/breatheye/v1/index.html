<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<title>burak.wtf — hollow ring + precessing moon orbit</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; padding:0; height:100%; background:#000; }
  body { display:flex; align-items:center; justify-content:center; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:#fff; user-select:none; }
  canvas.stage { position:fixed; inset:0; touch-action:none; }

  /* Alt menü (açık), başlıklar kapalı */
  .bottom {
    position: fixed; left:0; right:0; bottom:0;
    background: rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
    border-top: 1px solid rgba(255,255,255,.15);
    padding: 8px 10px;
    display: grid; gap: 8px; z-index: 2;
  }
  .sections { display:grid; grid-template-columns: repeat(2, minmax(260px,1fr)); gap:8px; }
  @media (max-width: 820px){ .sections { grid-template-columns: 1fr; } }
  details { border:1px solid rgba(255,255,255,.15); border-radius:10px; overflow:clip; background:rgba(255,255,255,.04); }
  summary { list-style:none; cursor:pointer; padding:8px 10px; font-size:12px; letter-spacing:.02em; display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,.05); }
  summary::-webkit-details-marker{ display:none; }
  .caret{ opacity:.7; transition: transform .2s ease; } details[open] .caret{ transform: rotate(90deg); }
  .content { padding:8px 10px; }
  .grid3 { display:grid; gap:10px 12px; grid-template-columns:auto 1fr auto; align-items:center; }
  .label { opacity:.8; white-space:nowrap; font-size:12px; }
  input[type="range"] { width:100%; touch-action: pan-y; }
  .val { font-variant-numeric: tabular-nums; opacity:.8; font-size:12px; }
  .row { grid-column:1/-1; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px; opacity:.85; }
</style>
</head>
<body>
<canvas id="c" class="stage"></canvas>

<!-- Bottom menu -->
<div id="bottom" class="bottom" role="region" aria-label="controls">
  <div class="sections">
    <!-- SHAPE -->
    <details id="shapeSec">
      <summary>Shape <span class="caret">▶</span></summary>
      <div class="content grid3">
        <div class="label">radius</div>
        <input id="radius" type="range" min="0.25" max="0.60" step="0.005" value="0.42">
        <div id="radiusVal" class="val">0.42</div>

        <div class="label">opacity</div>
        <input id="opacity" type="range" min="0.00" max="1.00" step="0.01" value="1.00">
        <div id="opacityVal" class="val">1.00</div>

        <div class="label">gain (×)</div>
        <input id="gain"   type="range" min="0.05" max="10.0" step="0.01" value="1.00">
        <div id="gainVal" class="val">1.00</div>

        <div class="label">moons</div>
        <input id="moonCount" type="range" min="1" max="6" step="1" value="1">
        <div id="moonCountVal" class="val">1</div>
      </div>
    </details>

    <!-- BREATHE -->
    <details id="breatheSec">
      <summary>Breathe <span class="caret">▶</span></summary>
      <div class="content grid3">
        <!-- LOG slider’lar: 0..1 -> 0.2s..120s -->
        <div class="label">inhale (s)</div>
        <input id="tin"  type="range" min="0" max="1" step="0.001" value="0.35">
        <div id="tinVal" class="val">3.0</div>

        <div class="label">exhale (s)</div>
        <input id="tout" type="range" min="0" max="1" step="0.001" value="0.70">
        <div id="toutVal" class="val">7.0</div>

        <div class="label">gain high</div>
        <input id="ghi"  type="range" min="0.00" max="20" step="0.01" value="7.77">
        <div id="ghiVal" class="val">7.77</div>

        <div class="label">gain low</div>
        <input id="glo"  type="range" min="0.00" max="10" step="0.01" value="0.33">
        <div id="gloVal" class="val">0.33</div>

        <div class="row">
          <label style="display:flex;align-items:center;gap:8px;">
            <input id="rationalChk" type="checkbox" />
            rational breathing
          </label>
          <div id="ratInfo"></div>
        </div>

        <div class="label">units (0–57)</div>
        <input id="rationalUnits" type="range" min="0" max="57" step="1" value="0" disabled>
        <div id="rationalVal" class="val">0</div>
      </div>
    </details>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 0, 3);

/* ================== RING (hollow, tek renk) ================== */
const ringGroup = new THREE.Group();
scene.add(ringGroup);

const planeGeo = new THREE.PlaneGeometry(2.8, 2.8, 1, 1);
const COLOR = '#FFD75A';

const ringMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime:   { value: 0 },
    uRadius: { value: 0.42 },
    uWidth:  { value: 2.8 },
    uGain:   { value: 1.0 },
    uAlpha:  { value: 1.0 },      // <-- Shape: opacity slider
    uColor:  { value: new THREE.Color(COLOR) },
  },
  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader: `
    precision highp float; varying vec2 vUv;
    uniform float uTime,uRadius,uWidth,uGain,uAlpha; uniform vec3 uColor;
    void main(){
      vec2 p = vUv - 0.5; float r = length(p) * 2.0;
      // ince halka (annulus). içi tamamen transparan, dışı karanlık
      float inner = 1.0 - smoothstep(uRadius - (1.0/uWidth), uRadius, r);
      float outer = smoothstep(uRadius, uRadius + (0.9/uWidth), r);
      float ring  = inner * (1.0 - outer);

      float a = ring * uGain * uAlpha;
      vec3  c = uColor * (0.98 + 0.02*sin(uTime*2.0));
      gl_FragColor = vec4(c*a, a);
      if(gl_FragColor.a < 0.001) discard;
    }
  `
});
const ringMesh = new THREE.Mesh(planeGeo, ringMat);
ringMesh.renderOrder = 2;
ringGroup.add(ringMesh);

/* ================== MOONS (ay gibi, dış orbit; düz dönme + rastgele düzlem precession) ================== */
let moons = [];
function createMoonMaterial(){
  return new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
    uniforms:{ uGain:{value:1.0}, uAlpha:{value:1.0}, uColor:{value:new THREE.Color(COLOR)} },
    vertexShader: `
      varying float vSizeScale; varying vec3 vColor;
      uniform float uGain, uAlpha;
      void main(){
        vColor = vec3(${new THREE.Color(COLOR).r.toFixed(3)}, ${new THREE.Color(COLOR).g.toFixed(3)}, ${new THREE.Color(COLOR).b.toFixed(3)});
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float base = 4.0;
        float boost = 2.0 * clamp(uGain/8.0, 0.0, 1.0);
        float distScale = (300.0 / -gl_Position.z);
        gl_PointSize = (base + boost) * distScale;
      }
    `,
    fragmentShader: `
      precision highp float; varying vec3 vColor; uniform float uAlpha;
      void main(){
        vec2 uv = gl_PointCoord*2.0 - 1.0;
        float d = dot(uv,uv);
        float a = exp(-d*5.5) * uAlpha;
        gl_FragColor = vec4(vColor*a, a);
      }
    `
  });
}
function rebuildMoons(n){
  moons.forEach(m=>{
    ringGroup.remove(m.mesh);
    m.mesh.geometry.dispose();
    m.mesh.material.dispose();
  });
  moons = [];
  for(let i=0;i<n;i++){
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(3), 3));
    const mat = createMoonMaterial();
    const mesh = new THREE.Points(geo, mat);
    mesh.renderOrder = 3;

    // rastgele parametreler
    const seed = Math.random()*1000;
    const baseR = 0.42 * (1.10 + 0.25*Math.random()); // halkanın DIŞI
    const baseW = 0.4 + Math.random()*0.6;            // açısal hız (rad/sn)
    const phase= Math.random()*Math.PI*2;

    // precession: düzlem eğimleri zamanla yavaşça değişecek
    const tiltAmp = 0.65; // max ~37°
    const tiltSpeedX = 0.10 + Math.random()*0.10; // çok yavaş
    const tiltSpeedY = 0.10 + Math.random()*0.10;

    moons.push({ mesh, seed, baseR, baseW, phase, tiltAmp, tiltSpeedX, tiltSpeedY });
    ringGroup.add(mesh);
  }
}
rebuildMoons(1);

/* ================== İnteraksiyon — inertial trackball ================== */
let yaw = 0, pitch = 0;         // rad
let yawVel = 0, pitchVel = 0;   // rad/s
let distance = 3;

let isDown=false, lastX=0, lastY=0, lastMoveT=performance.now();
const DRIVE=14.0, FRICTION=0.95, MAX_V=14.0;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function pointerXY(e){ if('clientX'in e) return [e.clientX,e.clientY]; if('touches'in e&&e.touches.length) return [e.touches[0].clientX,e.touches[0].clientY]; return [0,0]; }

canvas.addEventListener('pointerdown',(e)=>{ isDown=true; canvas.setPointerCapture(e.pointerId); [lastX,lastY]=pointerXY(e); lastMoveT=performance.now(); });
canvas.addEventListener('pointermove',(e)=>{
  if(!isDown) return;
  const [x,y]=pointerXY(e); const now=performance.now();
  let dt=(now-lastMoveT)/1000; if(dt<=0) dt=1/120;
  const dx=(x-lastX)/innerWidth, dy=(y-lastY)/innerHeight;
  lastX=x; lastY=y; lastMoveT=now;
  const k=Math.PI;
  const tYaw=clamp((-dx*k)/dt,-MAX_V,MAX_V);
  const tPit=clamp((-dy*k*0.7)/dt,-MAX_V,MAX_V);
  const a=1.0-Math.exp(-DRIVE*dt);
  yawVel+=(tYaw-yawVel)*a; pitchVel+=(tPit-pitchVel)*a;
});
canvas.addEventListener('pointerup',(e)=>{ isDown=false; canvas.releasePointerCapture(e.pointerId); });
addEventListener('wheel',(e)=>{ distance+=Math.sign(e.deltaY)*0.15; distance=clamp(distance,1.4,6.0); },{passive:true});
let pinchStart=0;
canvas.addEventListener('touchstart',(e)=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinchStart=Math.hypot(dx,dy);} },{passive:true});
canvas.addEventListener('touchmove',(e)=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const d=Math.hypot(dx,dy); const s=(pinchStart>0)?(pinchStart/d):1.0; distance=clamp(distance*s,1.4,6.0); pinchStart=d; } },{passive:true});

/* ================== Kontroller ================== */
const radiusEl = document.getElementById('radius');
const opacityEl= document.getElementById('opacity');
const gainEl   = document.getElementById('gain');
const moonCountEl = document.getElementById('moonCount');

const radiusVal = document.getElementById('radiusVal');
const opacityVal= document.getElementById('opacityVal');
const gainVal   = document.getElementById('gainVal');
const moonCountVal = document.getElementById('moonCountVal');

const tinEl   = document.getElementById('tin');   // 0..1 (log)
const toutEl  = document.getElementById('tout');  // 0..1 (log)
const ghiEl   = document.getElementById('ghi');
const gloEl   = document.getElementById('glo');

const tinVal  = document.getElementById('tinVal');
const toutVal = document.getElementById('toutVal');
const ghiVal  = document.getElementById('ghiVal');
const gloVal  = document.getElementById('gloVal');

const rationalChk   = document.getElementById('rationalChk');
const rationalUnits = document.getElementById('rationalUnits');
const rationalVal   = document.getElementById('rationalVal');
const ratInfo       = document.getElementById('ratInfo');

/* LOG haritalama: slider t∈[0,1] → secs∈[0.2,120] */
const S_MIN=0.2, S_MAX=120;
const logMap = (t)=> Math.exp( Math.log(S_MIN)*(1-t) + Math.log(S_MAX)*t );

function updUI(){
  radiusVal.textContent = (+radiusEl.value).toFixed(2);
  opacityVal.textContent= (+opacityEl.value).toFixed(2);
  gainVal.textContent   = (+gainEl.value).toFixed(2);
  moonCountVal.textContent = moonCountEl.value;

  const inh=logMap(+tinEl.value), exh=logMap(+toutEl.value);
  tinVal.textContent  = inh.toFixed(inh<10?2:1);
  toutVal.textContent = exh.toFixed(exh<10?2:1);
  ghiVal.textContent  = (+ghiEl.value).toFixed(2);
  gloVal.textContent  = (+gloEl.value).toFixed(2);
  rationalVal.textContent = rationalUnits.value;
}

radiusEl.addEventListener('input', ()=>{
  const r = parseFloat(radiusEl.value);
  ringMat.uniforms.uRadius.value = r;
  // mevcut ayların hedef yarıçaplarını güncelle (halka dışı kalsın)
  moons.forEach(m=> m.baseR = r * (1.10 + 0.25*Math.random()));
  updUI();
});
opacityEl.addEventListener('input', ()=>{
  const a = parseFloat(opacityEl.value);
  ringMat.uniforms.uAlpha.value = a;
  moons.forEach(m=> m.mesh.material.uniforms.uAlpha.value = a);
  updUI();
});
gainEl.addEventListener('input', updUI);
moonCountEl.addEventListener('change', ()=>{
  rebuildMoons(parseInt(moonCountEl.value,10));
  // opacity’yi yeni mat’lere uygula
  moons.forEach(m=> m.mesh.material.uniforms.uAlpha.value = parseFloat(opacityEl.value));
  updUI();
});

tinEl.addEventListener('input', updUI);
toutEl.addEventListener('input', updUI);
ghiEl.addEventListener('input', updUI);
gloEl.addEventListener('input', updUI);

/* Rational breathing 0–57 */
rationalChk.addEventListener('change', ()=>{
  const on = rationalChk.checked;
  rationalUnits.disabled = !on;
  tinEl.disabled = toutEl.disabled = on;
  updateRatInfo();
});
rationalUnits.addEventListener('input', ()=>{ rationalVal.textContent=rationalUnits.value; updateRatInfo(); });
function fmtSecs(x){ if(x>3600)return (x/3600).toFixed(1)+'h'; if(x>600)return (x/60).toFixed(1)+'m'; return x.toFixed(x<10?2:1)+'s'; }
function fibPair(n){ if(n<=0)return [0n,0n]; let a=0n,b=1n; for(let i=1;i<=n;i++){const t=a+b; a=b; b=t;} return [a,b]; }
function bigToNum(bi){ const MAX=1e12; const n=Number(bi); return !Number.isFinite(n)?MAX:Math.min(n,MAX); }
function updateRatInfo(){
  const n=parseInt(rationalUnits.value,10);
  if(!rationalChk.checked){ ratInfo.textContent=''; return; }
  if(n===0){ ratInfo.textContent='breathless (sabit)'; return; }
  const [Fi,Fj]=fibPair(n); const i=bigToNum(Fi), j=bigToNum(Fj);
  ratInfo.textContent = `N=${n} → inhale=${fmtSecs(i)} • exhale=${fmtSecs(j)}`;
}

/* ================== NEFES MOTORU ================== */
function breathGain(t, tinSec, toutSec, lo, hi){
  tinSec=Math.max(0.0,tinSec); toutSec=Math.max(0.0,toutSec);
  const T=tinSec+toutSec;
  if(T<1e-6) return (lo+hi)*0.5;
  const ph = t % T;
  if(ph < tinSec){ const u=ph/tinSec; return lo + (hi-lo)*u; }
  else { const u=(ph-tinSec)/toutSec; return hi + (lo-hi)*u; }
}

/* ================== ANIMATE ================== */
const clock = new THREE.Clock();
function tick(){
  const t  = clock.getElapsedTime();
  const dt = clock.getDelta();

  // Atalet
  const decay=Math.exp(-0.95*dt);
  yawVel*=decay; pitchVel*=decay;
  yaw += yawVel*dt; pitch += pitchVel*dt;
  pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));

  ringGroup.rotation.set(pitch, yaw, 0);
  camera.position.set(0, 0, distance);
  camera.lookAt(0, 0, 0);

  // Nefes (rational varsa override)
  let tinSec = logMap(+tinEl.value);
  let toutSec= logMap(+toutEl.value);
  if (rationalChk.checked){
    const n = parseInt(rationalUnits.value,10);
    if (n===0){ tinSec=0; toutSec=0; }
    else { const [Fi,Fj]=fibPair(n); tinSec=bigToNum(Fi); toutSec=bigToNum(Fj); }
  }
  const lo=parseFloat(gloEl.value), hi=parseFloat(ghiEl.value), gMul=parseFloat(gainEl.value);
  const gBreath = breathGain(t, tinSec, toutSec, lo, hi);
  const g = gBreath * gMul;

  // Ring gain
  ringMat.uniforms.uGain.value = g;
  ringMat.uniforms.uTime.value = t;

  // Moons: düz dairesel hareket + yavaş precession (düzlem değişimi)
  moons.forEach((m,i)=>{
    const pos = m.mesh.geometry.attributes.position.array;
    // düz daire açısı
    const th = m.phase + t * m.baseW * (0.6 + 0.6*Math.min(Math.log(1.0+g), 2.0)); // nefesle biraz hızlanır

    // precession — yörünge düzlemi zamanla değişsin:
    const tx = Math.sin(t*m.tiltSpeedX + m.seed) * m.tiltAmp;
    const ty = Math.sin(t*m.tiltSpeedY + m.seed*1.37) * m.tiltAmp;

    // temel daire (XY)
    let x = Math.cos(th) * m.baseR * 1.15;
    let y = Math.sin(th) * m.baseR * 1.15;
    let z = 0.0;

    // önce Y etrafında tilt (x-z)
    const x1 =  x*Math.cos(ty) + z*Math.sin(ty);
    const z1 = -x*Math.sin(ty) + z*Math.cos(ty);
    // sonra X etrafında tilt (y-z)
    const y2 =  y*Math.cos(tx) - z1*Math.sin(tx);
    const z2 =  y*Math.sin(tx) + z1*Math.cos(tx);

    pos[0] = x1 * 1.0;
    pos[1] = y2 * 1.0;
    pos[2] = z2 * 0.12; // az derinlik

    m.mesh.geometry.attributes.position.needsUpdate = true;

    // gain & opacity'yi gönder
    m.mesh.material.uniforms.uGain.value  = g;
    m.mesh.material.uniforms.uAlpha.value = parseFloat(opacityEl.value);
  });

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

/* Resize */
addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });

/* Başlangıç: başlıklar kapalı ve UI yazıları */
document.getElementById('shapeSec').open=false;
document.getElementById('breatheSec').open=false;
(function initUI(){
  ringMat.uniforms.uRadius.value = parseFloat(radiusEl.value);
  ringMat.uniforms.uAlpha.value  = parseFloat(opacityEl.value);
  moons.forEach(m=> m.mesh.material.uniforms.uAlpha.value = parseFloat(opacityEl.value));
  updUI();
})();
</script>
</body>
</html>
