<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<title>burak.wtf — ring • fling + auto + quantum + golden menu + breath gain</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
<style>
  :root { --phi: 1.618; color-scheme: dark; }
  html, body { margin:0; padding:0; height:100%; background:#000; }
  body { display:flex; align-items:center; justify-content:center; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color:#fff; user-select:none; }
  canvas.stage { position:fixed; inset:0; touch-action:none; }

  /* Quantum FAB (sağ altta top) */
  .fab {
    position: fixed; right: 16px; bottom: 16px;
    width: 60px; height: 60px; border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #fff, #bdb76b 40%, #6b6b45 70%, #000 100%);
    box-shadow:
      0 8px 24px rgba(189,183,107,.35),
      inset 0 0 18px rgba(255,255,255,.25);
    border: 1px solid rgba(255,255,255,.22);
    cursor: pointer; display:grid; place-items:center;
    transition: transform .12s ease, box-shadow .2s ease, filter .2s ease;
    will-change: transform, filter;
  }
  .fab:hover { transform: scale(1.04); filter: saturate(1.15) brightness(1.05); }
  .fab:active { transform: scale(0.96); }

  /* Golden-ratio panel (sağ alt, altın oran) */
  .panel {
    position: fixed; right: 16px; bottom: 88px;
    width: clamp(280px, 34vw, 520px);
    aspect-ratio: var(--phi) / 1; /* genişlik:yükseklik = 1.618 */
    max-height: min(70vh, 560px);
    background: rgba(0,0,0,.55);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,.15);
    border-radius: 16px;
    box-shadow: 0 12px 36px rgba(0,0,0,.5);
    padding: 12px;
    display: none;
  }
  .panel.open { display:block; }
  .panel h1 { margin:0 0 8px 0; font-size:12px; letter-spacing:.04em; opacity:.8; }
  .grid { display:grid; grid-template-columns:auto 1fr auto; gap:8px 10px; align-items:center; }
  .label { opacity:.78; white-space:nowrap; font-size:12px; }
  input[type="range"] { width: 100%; }
  .row { grid-column: 1 / -1; display:flex; gap:8px; align-items:center; }
  .btn {
    appearance:none; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08);
    color:#fff; padding:6px 10px; border-radius: 10px; font-size:12px; cursor:pointer;
  }
  .toggle { accent-color:#fff; }
  .hint {
    position: fixed; left:16px; bottom: 16px; opacity:.6; font-size:12px;
  }

  /* Mobile optimizations */
  @media (max-width: 640px) {
    .panel { left: 16px; right: 16px; width:auto; }
  }
</style>
</head>
<body>
<canvas id="c" class="stage"></canvas>

<!-- Quantum ball -->
<button id="fab" class="fab" aria-label="open controls">Q</button>

<!-- Golden-ratio control panel -->
<div id="panel" class="panel" role="dialog" aria-modal="false">
  <h1>ring • controls</h1>
  <div class="grid">
    <div class="label">radius</div><input id="radius" type="range" min="0.25" max="0.60" step="0.005" value="0.42"><div id="radiusVal">0.42</div>
    <div class="label">inner</div> <input id="inner"  type="range" min="0.00" max="1.00"  step="0.01"  value="0.60"><div id="innerVal">0.60</div>

    <div class="label">auto-rotate</div><input id="autoChk" class="toggle" type="checkbox" checked><div></div>
    <div class="label">auto speed</div><input id="autoSpd" type="range" min="-2.0" max="2.0" step="0.01" value="0.25"><div id="autoSpdVal">0.25</div>

    <div class="label">quantum</div><input id="quantChk" class="toggle" type="checkbox" checked><div></div>
    <div class="label">quant amt</div><input id="quantAmt" type="range" min="0.0" max="1.0" step="0.01" value="0.35"><div id="quantAmtVal">0.35</div>

    <div class="label">friction</div><input id="fric" type="range" min="0.2" max="4.0" step="0.01" value="0.85"><div id="fricVal">0.85</div>

    <div class="row" style="margin-top:6px">
      <button id="reset" class="btn">reset view (R)</button>
      <button id="pause" class="btn">pause</button>
    </div>

    <div class="row" style="opacity:.65; font-size:12px;">
      mouse/touch: drag=rotate, fling=continue, wheel/pinch=zoom • keys: ← → ↑ ↓ / WASD • A: auto • Q: quantum • M: menu
    </div>
  </div>
</div>

<div class="hint">drag to rotate • fling continues • pinch/wheel to zoom • press <b>M</b> or tap the ball → menu</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1); // siyah arka plan

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 0, 3);

/* ================== RING (iç parlak, dış tamamen karanlık) ================== */
const ringGroup = new THREE.Group();
scene.add(ringGroup);

const planeGeo = new THREE.PlaneGeometry(2, 2, 1, 1);

const ringMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uRadius: { value: 0.42 },
    uWidth: { value: 2.5 },
    uGain: { value: 1.0 },
    uBrightness: { value: 1.0 },
    uRingColor: { value: new THREE.Color('#ffffff') },
    uInnerColor:{ value: new THREE.Color('#BDB76B') }, // DarkKhaki
    uInnerStrength:{ value: 0.60 },
  },
  vertexShader: /* glsl */`
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: /* glsl */`
    precision highp float;
    varying vec2 vUv;

    uniform float uTime, uRadius, uWidth, uGain, uBrightness;
    uniform vec3  uRingColor, uInnerColor;
    uniform float uInnerStrength;

    void main(){
      vec2 p = vUv - 0.5;
      float r = length(p) * 2.0;

      // Ring band (yumuşak)
      float innerEdge = smoothstep(uRadius - (1.0/uWidth), uRadius, r);
      float outerEdge = 1.0 - smoothstep(uRadius, uRadius + (0.7/uWidth), r);
      float ringBand  = innerEdge * outerEdge;

      // İç parıltı (merkeze doğru yumuşak artış)
      float innerFill = smoothstep(uRadius, 0.0, r);
      float innerSoft = exp(-pow((uRadius - r) * (uWidth*0.7), 2.0));
      float innerHaze = clamp(innerFill * innerSoft, 0.0, 1.0);

      // Dış alanı hızlıca söndür (tamamen karanlık)
      float hardCut = 1.0 - smoothstep(uRadius + (0.9/uWidth), uRadius + (1.4/uWidth), r);
      float mask = max(ringBand, innerFill) * hardCut;

      float aRing  = ringBand;
      float aInner = innerHaze * uInnerStrength;

      float a = (aRing + aInner) * uGain * clamp(uBrightness, 0.0, 1.0);
      a *= mask;
      a = clamp(a, 0.0, 1.0);

      vec3 col = vec3(0.0);
      col += uRingColor * aRing * 1.0;
      col += uInnerColor * aInner * 0.9;

      gl_FragColor = vec4(col, a);
      if (gl_FragColor.a < 0.001) discard;
    }
  `
});

const ringMesh = new THREE.Mesh(planeGeo, ringMat);
ringMesh.renderOrder = 1;
ringGroup.add(ringMesh);

/* ================== ETKİLEŞİM (fling, auto, quantum, klavye, dokunma) ================== */
let yaw = 0, pitch = 0;
let yawVel = 0, pitchVel = 0;      // rad/s
let isDown = false, lastX = 0, lastY = 0;
let distance = 3;
let paused = false;

const clamp = (x, a, b)=> Math.max(a, Math.min(b, x));

/* Pointer: gerçek fling (son N hız ortalaması) */
const SAMPLES = 6;
const velBuf = Array.from({length:SAMPLES}, ()=>({vx:0, vy:0}));
let vi = 0, lastMoveT = performance.now();

const getXY = (e)=> ('clientX' in e ? [e.clientX, e.clientY]
                    : ('touches' in e ? [e.touches[0].clientX, e.touches[0].clientY] : [0,0]));

canvas.addEventListener('pointerdown', (e)=>{
  isDown = true;
  canvas.setPointerCapture(e.pointerId);
  [lastX, lastY] = getXY(e);
  yawVel = 0; pitchVel = 0;
  for (let k=0;k<SAMPLES;k++) velBuf[k] = {vx:0, vy:0};
  lastMoveT = performance.now();
});

canvas.addEventListener('pointermove', (e)=>{
  if (!isDown) return;
  const [x, y] = getXY(e);
  const now = performance.now();
  const dt = Math.max(1, now - lastMoveT) / 1000; // s
  const dx = (x - lastX) / innerWidth;
  const dy = (y - lastY) / innerHeight;
  lastX = x; lastY = y; lastMoveT = now;

  const k = Math.PI; // hassasiyet
  yaw   -= dx * k;
  pitch -= dy * k * 0.7;
  pitch = clamp(pitch, -Math.PI/2, Math.PI/2);

  // anlık hız (rad/s)
  velBuf[vi] = { vx: (-dx * k) / dt, vy: (-dy * k * 0.7) / dt };
  vi = (vi + 1) % SAMPLES;
});

canvas.addEventListener('pointerup', (e)=>{
  isDown = false;
  canvas.releasePointerCapture(e.pointerId);
  let sx=0, sy=0;
  for (let k=0;k<SAMPLES;k++){ sx+=velBuf[k].vx; sy+=velBuf[k].vy; }
  yawVel   = sx / SAMPLES;
  pitchVel = sy / SAMPLES;
  const MAX_V = 12; // rad/s tavan
  yawVel   = clamp(yawVel, -MAX_V, MAX_V);
  pitchVel = clamp(pitchVel, -MAX_V, MAX_V);
});

/* Wheel zoom */
addEventListener('wheel', (e)=>{
  distance += Math.sign(e.deltaY) * 0.15;
  distance = clamp(distance, 1.4, 6.0);
}, { passive:true });

/* Pinch zoom (touch) */
let pinchStart = 0;
canvas.addEventListener('touchstart', (e)=>{
  if (e.touches.length === 2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchStart = Math.hypot(dx, dy);
  }
}, { passive:true });
canvas.addEventListener('touchmove', (e)=>{
  if (e.touches.length === 2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const d  = Math.hypot(dx, dy);
    const s  = (pinchStart > 0) ? (pinchStart / d) : 1.0;
    distance = clamp(distance * s, 1.4, 6.0);
    pinchStart = d;
  }
}, { passive:true });

/* Klavye (PC): oklar + WASD + hız ekleme */
addEventListener('keydown', (e)=>{
  const accel = 1.6; // rad/s ek hız
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') yawVel += accel;
  if (e.key === 'ArrowRight'|| e.key === 'd' || e.key === 'D') yawVel -= accel;
  if (e.key === 'ArrowUp'   || e.key === 'w' || e.key === 'W') pitchVel += accel*0.7;
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') pitchVel -= accel*0.7;

  if (e.key === ' ') { paused = !paused; }                 // Space: pause
  if (e.key === 'r' || e.key === 'R') resetView();         // R: reset
  if (e.key === 'm' || e.key === 'M') togglePanel();       // M: menu
  if (e.key === 'q') quantChk.checked = !quantChk.checked; // q: quantum
  if (e.key === 'A') autoChk.checked  = !autoChk.checked;  // A: auto
});

/* ================== PANEL & FAB ================== */
const panel = document.getElementById('panel');
const fab   = document.getElementById('fab');
function togglePanel(){ panel.classList.toggle('open'); }
fab.addEventListener('click', togglePanel);

/* Controls */
const radiusEl = document.getElementById('radius');
const innerEl  = document.getElementById('inner');
const autoChk  = document.getElementById('autoChk');
const autoSpd  = document.getElementById('autoSpd');
const quantChk = document.getElementById('quantChk');
const quantAmt = document.getElementById('quantAmt');
const fricEl   = document.getElementById('fric');

const radiusVal = document.getElementById('radiusVal');
const innerVal  = document.getElementById('innerVal');
const autoSpdVal= document.getElementById('autoSpdVal');
const quantAmtVal=document.getElementById('quantAmtVal');
const fricVal   = document.getElementById('fricVal');

const resetBtn = document.getElementById('reset');
const pauseBtn = document.getElementById('pause');

const upd = ()=>{
  radiusVal.textContent = (+radiusEl.value).toFixed(2);
  innerVal .textContent = (+innerEl.value ).toFixed(2);
  autoSpdVal.textContent= (+autoSpd.value ).toFixed(2);
  quantAmtVal.textContent= (+quantAmt.value).toFixed(2);
  fricVal   .textContent= (+fricEl.value  ).toFixed(2);
};
radiusEl.addEventListener('input', ()=>{ ringMat.uniforms.uRadius.value = parseFloat(radiusEl.value); upd(); });
innerEl .addEventListener('input', ()=>{ ringMat.uniforms.uInnerStrength.value = parseFloat(innerEl.value); upd(); });
autoSpd .addEventListener('input', upd);
quantAmt.addEventListener('input', upd);
fricEl  .addEventListener('input', upd);

function resetView(){
  yaw = 0; pitch = 0; yawVel = 0; pitchVel = 0; distance = 3;
}
resetBtn.addEventListener('click', resetView);
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'resume' : 'pause'; });

/* ================== QUANTUM JITTER ================== */
const fract = (x)=> x - Math.floor(x);
const hash  = (t)=> fract(Math.sin(t*12.9898 + 78.233) * 43758.5453123);
const n11   = (t)=> hash(t) * 2.0 - 1.0;

/* ================== BREATH GAIN (3s → 7.77, 7s → 0.33) ================== */
const G_HI = 7.77, G_LO = 0.33, T_IN = 3.0, T_OUT = 7.0, T_CYCLE = T_IN + T_OUT;
function breathGain(t){
  const ph = (t % T_CYCLE);
  if (ph < T_IN){
    return G_LO + (G_HI - G_LO) * (ph / T_IN); // inhale (3s)
  } else {
    const u = (ph - T_IN) / T_OUT;
    return G_HI + (G_LO - G_HI) * u;          // exhale (7s)
  }
}

/* Gain slider yerine otomatik nefes: kullanıcı dokunmazsa devrede */
let lastGainTouch = -1;      // saniye cinsinden
const MANUAL_HOLD = 5.0;     // slider’a dokunduğunda şu süre manuel kalsın (s)
const gainSliderGhost = { value: 1.0 }; // (gizli) mevcut slider değeri (yalnızca quantum kullandığında da güncellensin istersen ekleyebiliriz)

const clock = new THREE.Clock();
const startAt = performance.now()/1000;

function nowSec(){ return startAt + clock.getElapsedTime(); }

/* ================== ANIMATE ================== */
function tick(){
  const t  = clock.getElapsedTime();
  const dt = clock.getDelta();
  if (paused){ requestAnimationFrame(tick); return; }

  // Auto-rotate (yaw)
  if (autoChk.checked){
    const spd = parseFloat(autoSpd.value); // rad/s
    yaw += spd * dt;
  }

  // Quantum jitter: küçük açısal + yarıçap mikro titreşim (gain’e dokunmaz)
  if (quantChk.checked){
    const q = parseFloat(quantAmt.value);
    yaw   += n11(t*3.1) * 0.08 * q * dt;
    pitch += n11(t*2.3+10.5) * 0.06 * q * dt;

    // radius flutter (göze hoş bir canlılık)
    const r0 = parseFloat(radiusEl.value);
    const rJ = r0 + (n11(t*1.7+2.7) * 0.003 * q);
    ringMat.uniforms.uRadius.value = rJ;
  } else {
    ringMat.uniforms.uRadius.value = parseFloat(radiusEl.value);
  }

  // Fling atalet / sürtünme (dokunmuyorken)
  const friction = parseFloat(fricEl.value);
  const decay = Math.exp(-(isDown ? 0.0 : friction) * dt);
  if (!isDown){
    yaw   += yawVel   * dt;
    pitch += pitchVel * dt;
    yawVel   *= decay;
    pitchVel *= decay;
  }
  pitch = clamp(pitch, -Math.PI/2, Math.PI/2);

  // Kamera ve dönüş
  ringGroup.rotation.set(pitch, yaw, 0);
  camera.position.set(0, 0, distance);
  camera.lookAt(0, 0, 0);

  // NEFES GAIN: slider’a son dokunuştan MANUAL_HOLD saniye sonra otomatik nefese dön
  const tAbs = nowSec();
  let useBreath = true;
  if (lastGainTouch > 0 && (tAbs - lastGainTouch) < MANUAL_HOLD) useBreath = false;

  let gainValue;
  if (useBreath){
    gainValue = breathGain(t);
  } else {
    // (Panelde gain slider göstermiyoruz; nefes otomatik. İstersen kolayca eklenir.)
    // Yine de geleceğe hazırlık: gainSliderGhost.value kullanılabilir.
    gainValue = breathGain(t); // burada sabit tutmak istersen, gainSliderGhost.value de kullanabilirsin
  }
  ringMat.uniforms.uGain.value = gainValue;

  // hafif taban nefesi (parlaklık)
  const breathe = 0.02 * Math.sin(t * 0.6);
  ringMat.uniforms.uBrightness.value = 1.0 + breathe;
  ringMat.uniforms.uTime.value = t;

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

/* Resize */
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* Eğer ileride gain slider eklersen, şu listener ile lastGainTouch’ı güncelle: */
// gainEl.addEventListener('input', ()=>{ lastGainTouch = nowSec(); gainSliderGhost.value = parseFloat(gainEl.value); });

/* Panel dışına tıklayınca kapatma (mobil için kolaylık) */
document.addEventListener('click', (e)=>{
  if (!panel.classList.contains('open')) return;
  const path = e.composedPath ? e.composedPath() : [];
  if (!path.includes(panel) && !path.includes(fab)) panel.classList.remove('open');
}, true);
</script>
</body>
</html>
