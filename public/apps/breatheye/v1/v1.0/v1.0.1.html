<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<title>burak.wtf — center light • fling inertia + breath gain</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
<style>
  :root { --phi: 1.618; color-scheme: dark; }
  html, body { margin:0; padding:0; height:100%; background:#000; }
  body { display:flex; align-items:center; justify-content:center; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:#fff; user-select:none; }
  canvas.stage { position:fixed; inset:0; touch-action:none; }

  /* Sol altta minicik, işlevsiz “top” */
  .dot {
    position: fixed; left: 12px; bottom: 12px;
    width: 10px; height: 10px; border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #bdb76b, #6b6b45 60%, #000 100%);
    border: 1px solid rgba(255,255,255,.15);
    box-shadow: 0 2px 6px rgba(189,183,107,.25);
    pointer-events: none;
  }

  /* Sağ altta altın oranlı, yatay uzun panel */
  .panel {
    position: fixed; right: 14px; bottom: 14px;
    width: clamp(320px, 44vw, 820px);       /* yatay uzun */
    aspect-ratio: var(--phi) / 1;            /* 1.618:1 */
    max-height: min(72vh, 560px);
    background: rgba(0,0,0,.56);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,.15);
    border-radius: 16px;
    box-shadow: 0 14px 38px rgba(0,0,0,.55);
    padding: 12px;
    display: grid;
    grid-template-rows: auto 1fr;
    gap: 10px;
  }
  .panel h1 { margin:0; font-size:12px; letter-spacing:.04em; opacity:.8; }
  .grid { display:grid; grid-template-columns: auto 1fr auto; gap:10px 12px; align-items:center; overflow:auto; }
  .label { opacity:.8; white-space:nowrap; font-size:12px; }
  input[type="range"] { width: 100%; touch-action: pan-y; }
  .val { font-variant-numeric: tabular-nums; opacity:.8; font-size:12px; }

  .hint {
    position: fixed; left: 14px; bottom: 34px; opacity:.6; font-size:12px;
  }

  @media (max-width: 640px) {
    .panel { left: 14px; right: 14px; width:auto; aspect-ratio:auto; max-height: 50vh; }
    .grid { gap:8px 10px; }
  }
</style>
</head>
<body>
<canvas id="c" class="stage"></canvas>

<!-- İşlevsiz minik top (sol alt) -->
<div class="dot" aria-hidden="true"></div>

<!-- Kontrol Paneli (sağ alt, yatay, altın oran) -->
<div id="panel" class="panel" role="group" aria-label="controls">
  <h1>ring • controls</h1>
  <div class="grid">
    <div class="label">radius</div><input id="radius" type="range" min="0.25" max="0.60" step="0.005" value="0.42"><div id="radiusVal" class="val">0.42</div>
    <div class="label">inner</div> <input id="inner"  type="range" min="0.00" max="1.00"  step="0.01"  value="0.60"><div id="innerVal"  class="val">0.60</div>

    <div class="label">gain (×)</div><input id="gain"   type="range" min="0.05" max="10.0" step="0.01" value="1.00"><div id="gainVal"   class="val">1.00</div>

    <div class="label">inhale (s)</div><input id="tin"  type="range" min="0.2" max="120" step="0.1" value="3.0"><div id="tinVal"  class="val">3.0</div>
    <div class="label">exhale (s)</div><input id="tout" type="range" min="0.2" max="120" step="0.1" value="7.0"><div id="toutVal" class="val">7.0</div>

    <div class="label">gain high</div><input id="ghi"  type="range" min="0.00" max="20" step="0.01" value="7.77"><div id="ghiVal" class="val">7.77</div>
    <div class="label">gain low</div> <input id="glo"  type="range" min="0.00" max="10" step="0.01" value="0.33"><div id="gloVal" class="val">0.33</div>
  </div>
</div>

<div class="hint">drag to rotate • fling continues (inertia) • pinch/wheel to zoom • keys: ← → ↑ ↓ / WASD</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 0, 3);

/* ================== IŞIK KALIBI (tek plane) ================== */
const ringGroup = new THREE.Group();
scene.add(ringGroup);

const planeGeo = new THREE.PlaneGeometry(2, 2, 1, 1);

const ringMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uRadius: { value: 0.42 },
    uWidth: { value: 2.5 },
    uGain: { value: 1.0 },         // breath * gain slider
    uBrightness: { value: 1.0 },
    uRingColor: { value: new THREE.Color('#ffffff') },
    uInnerColor:{ value: new THREE.Color('#BDB76B') }, // DarkKhaki
    uInnerStrength:{ value: 0.60 },
  },
  vertexShader: /* glsl */`
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: /* glsl */`
    precision highp float;
    varying vec2 vUv;

    uniform float uTime;
    uniform float uRadius;
    uniform float uWidth;
    uniform float uGain;
    uniform float uBrightness;
    uniform vec3  uRingColor;
    uniform vec3  uInnerColor;
    uniform float uInnerStrength;

    void main(){
      vec2 p = vUv - 0.5;
      float r = length(p) * 2.0;

      // Ring band (yumuşak dar bant)
      float innerEdge = smoothstep(uRadius - (1.0/uWidth), uRadius, r);
      float outerEdge = 1.0 - smoothstep(uRadius, uRadius + (0.7/uWidth), r);
      float ringBand  = innerEdge * outerEdge;

      // İç parıltı (merkeze doğru yumuşak artış)
      float innerFill = smoothstep(uRadius, 0.0, r);
      float innerSoft = exp(-pow((uRadius - r) * (uWidth*0.7), 2.0));
      float innerHaze = clamp(innerFill * innerSoft, 0.0, 1.0);

      // Dış alan tamamen söner
      float hardCut = 1.0 - smoothstep(uRadius + (0.9/uWidth), uRadius + (1.4/uWidth), r);
      float mask = max(ringBand, innerFill) * hardCut;

      float aRing  = ringBand;
      float aInner = innerHaze * uInnerStrength;

      float a = (aRing + aInner) * uGain * clamp(uBrightness, 0.0, 1.0);
      a *= mask;
      a = clamp(a, 0.0, 1.0);

      vec3 col = vec3(0.0);
      col += uRingColor * aRing * 1.0;
      col += uInnerColor * aInner * 0.9;

      gl_FragColor = vec4(col, a);
      if (gl_FragColor.a < 0.001) discard;
    }
  `
});

const ringMesh = new THREE.Mesh(planeGeo, ringMat);
ringMesh.renderOrder = 1;
ringGroup.add(ringMesh);

/* ================== ETKİLEŞİM — İnertial Trackball (merkezden X/Y) ================== */
let yaw = 0, pitch = 0;         // rad
let yawVel = 0, pitchVel = 0;   // rad/s
let distance = 3;

let isDown = false, lastX = 0, lastY = 0;
let lastMoveT = performance.now();

/* Fizik parametreleri (tatlı ivme + yumuşak yavaşlama) */
const DRIVE = 10.0;     // pointer hızına yaklaşma hızı (1/s) -> yüksek = daha agresif hızlanma
const FRICTION = 1.25;  // sürtünme (1/s) -> yüksek = daha çabuk durur
const MAX_V = 12.0;     // maksimum açısal hız (rad/s)

const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

function pointerXY(e){
  if ('clientX' in e) return [e.clientX, e.clientY];
  if ('touches' in e && e.touches.length) return [e.touches[0].clientX, e.touches[0].clientY];
  return [0,0];
}

canvas.addEventListener('pointerdown', (e)=>{
  isDown = true;
  canvas.setPointerCapture(e.pointerId);
  [lastX, lastY] = pointerXY(e);
  lastMoveT = performance.now();
});

canvas.addEventListener('pointermove', (e)=>{
  if (!isDown) return;
  const [x,y] = pointerXY(e);
  const now = performance.now();
  let dt = (now - lastMoveT)/1000; if (dt <= 0) dt = 1/120; // s
  const dx = (x - lastX) / innerWidth;
  const dy = (y - lastY) / innerHeight;
  lastX = x; lastY = y; lastMoveT = now;

  // Hedef açısal hız (pointer hızından türet)
  const k = Math.PI; // hassasiyet
  const targetYawVel   = clamp((-dx * k) / dt, -MAX_V, MAX_V);
  const targetPitchVel = clamp((-dy * k * 0.7) / dt, -MAX_V, MAX_V);

  // Mevcut hızı hedefe doğru üstel yaklaştır (ivme hissi)
  const a = 1.0 - Math.exp(-DRIVE * dt);
  yawVel   = yawVel   + (targetYawVel   - yawVel)   * a;
  pitchVel = pitchVel + (targetPitchVel - pitchVel) * a;
});

canvas.addEventListener('pointerup', (e)=>{
  isDown = false;
  canvas.releasePointerCapture(e.pointerId);
});

/* Wheel zoom */
addEventListener('wheel', (e)=>{
  distance += Math.sign(e.deltaY) * 0.15;
  distance = clamp(distance, 1.4, 6.0);
}, { passive:true });

/* Pinch zoom (touch) */
let pinchStart = 0;
canvas.addEventListener('touchstart', (e)=>{
  if (e.touches.length === 2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchStart = Math.hypot(dx, dy);
  }
}, { passive:true });
canvas.addEventListener('touchmove', (e)=>{
  if (e.touches.length === 2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const d  = Math.hypot(dx, dy);
    const s  = (pinchStart > 0) ? (pinchStart / d) : 1.0;
    distance = clamp(distance * s, 1.4, 6.0);
    pinchStart = d;
  }
}, { passive:true });

/* Klavye (PC): oklar + WASD hıza katkı */
addEventListener('keydown', (e)=>{
  const kick = 2.0;
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') yawVel += kick;
  if (e.key === 'ArrowRight'|| e.key === 'd' || e.key === 'D') yawVel -= kick;
  if (e.key === 'ArrowUp'   || e.key === 'w' || e.key === 'W') pitchVel += kick*0.7;
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') pitchVel -= kick*0.7;
});

/* ================== PANEL KONTROLLERİ ================== */
const radiusEl = document.getElementById('radius');
const innerEl  = document.getElementById('inner');
const gainEl   = document.getElementById('gain');
const tinEl    = document.getElementById('tin');
const toutEl   = document.getElementById('tout');
const ghiEl    = document.getElementById('ghi');
const gloEl    = document.getElementById('glo');

const radiusVal = document.getElementById('radiusVal');
const innerVal  = document.getElementById('innerVal');
const gainVal   = document.getElementById('gainVal');
const tinVal    = document.getElementById('tinVal');
const toutVal   = document.getElementById('toutVal');
const ghiVal    = document.getElementById('ghiVal');
const gloVal    = document.getElementById('gloVal');

function upd(){
  radiusVal.textContent = (+radiusEl.value).toFixed(2);
  innerVal .textContent = (+innerEl.value ).toFixed(2);
  gainVal  .textContent = (+gainEl.value  ).toFixed(2);
  tinVal   .textContent = (+tinEl.value   ).toFixed(1);
  toutVal  .textContent = (+toutEl.value  ).toFixed(1);
  ghiVal   .textContent = (+ghiEl.value   ).toFixed(2);
  gloVal   .textContent = (+gloEl.value   ).toFixed(2);
}
radiusEl.addEventListener('input', ()=>{ ringMat.uniforms.uRadius.value = parseFloat(radiusEl.value); upd(); });
innerEl .addEventListener('input', ()=>{ ringMat.uniforms.uInnerStrength.value = parseFloat(innerEl.value); upd(); });
gainEl  .addEventListener('input', ()=>{ manualGainTouch = nowSec(); upd(); });
tinEl   .addEventListener('input', upd);
toutEl  .addEventListener('input', upd);
ghiEl   .addEventListener('input', upd);
gloEl   .addEventListener('input', upd);

/* ================== BREATH GAIN ================== */
/* Nefes: lo→hi (inhale) ve hi→lo (exhale). Gain slider çarpan olarak uygulanır. */
function breathGain(t, tin, tout, lo, hi){
  tin  = Math.max(0.001, tin);
  tout = Math.max(0.001, tout);
  const T = tin + tout;
  const ph = t % T;
  if (ph < tin){
    // inhale (lo → hi)
    const u = ph / tin;
    return lo + (hi - lo) * u;
  } else {
    // exhale (hi → lo)
    const u = (ph - tin) / tout;
    return hi + (lo - hi) * u;
  }
}

/* Gain slider'a dokunulduysa kısa süre “manuel his” verelim; sonra yine nefese bırakır. */
let manualGainTouch = -1;
const MANUAL_HOLD = 3.0; // s — slider’dan sonra şu kadar süre içinde değer sabitlenebilir (istersen artır/azalt)

/* ================== ANIMATE ================== */
const clock = new THREE.Clock();
function nowSec(){ return performance.now()/1000; }

function tick(){
  const t  = clock.getElapsedTime();
  const dt = clock.getDelta();

  /* Sürtünme ile hız sönümü (her durumda hafifçe uygula) */
  const decay = Math.exp(-FRICTION * dt);
  yawVel   *= decay;
  pitchVel *= decay;

  /* Hızları konuma entegre et */
  yaw   += yawVel   * dt;
  pitch += pitchVel * dt;
  pitch = clamp(pitch, -Math.PI/2, Math.PI/2);

  ringGroup.rotation.set(pitch, yaw, 0);
  camera.position.set(0, 0, distance);
  camera.lookAt(0, 0, 0);

  /* Nefes + gain çarpanı */
  const tin  = parseFloat(tinEl.value);
  const tout = parseFloat(toutEl.value);
  const ghi  = parseFloat(ghiEl.value);
  const glo  = parseFloat(gloEl.value);
  const gainMul = parseFloat(gainEl.value);

  // manuel dokunuştan hemen sonra istersen sabitleyebilirdik; ama isteğin “nefesi izleme”
  // olduğu için gain slider'ı yalnızca çarpan — nefes her zaman akar:
  const gBreath = breathGain(t, tin, tout, glo, ghi);
  ringMat.uniforms.uGain.value = gBreath * gainMul;

  // hafif taban parlaklık nefesi
  ringMat.uniforms.uBrightness.value = 1.0 + 0.02 * Math.sin(t * 0.6);
  ringMat.uniforms.uTime.value = t;

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
upd();
tick();

/* Resize */
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
