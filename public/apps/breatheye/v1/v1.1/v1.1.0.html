<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<title>if you don't mind</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no">
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; padding:0; height:100%; background:#000; }
  body { display:flex; align-items:center; justify-content:center; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:#fff; user-select:none; }
  canvas.stage { position:fixed; inset:0; touch-action:none; }

  /* Alt menü (açık), başlıklar kapalı */
  .bottom {
    position: fixed; left:0; right:0; bottom:0;
    background: rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
    border-top: 1px solid rgba(255,255,255,.15);
    padding: 8px 10px;
    display: grid; gap: 8px; z-index: 2;
  }
  .sections { display:grid; grid-template-columns: repeat(2, minmax(260px,1fr)); gap:8px; }
  @media (max-width: 820px){ .sections { grid-template-columns: 1fr; } }
  details { border:1px solid rgba(255,255,255,.15); border-radius:10px; overflow:clip; background:rgba(255,255,255,.04); }
  summary { list-style:none; cursor:pointer; padding:8px 10px; font-size:12px; letter-spacing:.02em; display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,.05); }
  summary::-webkit-details-marker{ display:none; }
  .caret{ opacity:.7; transition: transform .2s ease; } details[open] .caret{ transform: rotate(90deg); }
  .content { padding:8px 10px; }
  .grid3 { display:grid; gap:10px 12px; grid-template-columns:auto 1fr auto; align-items:center; }
  .label { opacity:.8; white-space:nowrap; font-size:12px; }
  input[type="range"] { width:100%; touch-action: pan-y; }
  .val { font-variant-numeric: tabular-nums; opacity:.8; font-size:12px; }
  .row { grid-column:1/-1; display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px; opacity:.85; }
</style>
</head>
<body>
<canvas id="c" class="stage"></canvas>

<!-- Bottom menu -->
<div id="bottom" class="bottom" role="region" aria-label="controls">
  <div class="sections">
    <!-- SHAPE -->
    <details id="shapeSec">
      <summary>Shape <span class="caret">▶</span></summary>
      <div class="content grid3">
        <div class="label">radius</div>
        <input id="radius" type="range" min="0.1" max="0.70" step="0.005" value="0.42">
        <div id="radiusVal" class="val">0.34</div>

        <div class="label">gain (×)</div>
        <input id="gain"   type="range" min="0.01" max="13.0" step="0.01" value="1.00">
        <div id="gainVal" class="val">5.55</div>

        <div class="label">orbits</div>
        <input id="orbitCount" type="range" min="40" max="400" step="10" value="180">
        <div id="orbitCountVal" class="val">180</div>
      </div>
    </details>

    <!-- BREATHE -->
    <details id="breatheSec">
      <summary>Breathe <span class="caret">▶</span></summary>
      <div class="content grid3">
        <!-- LOG slider’lar: 0..1 -> 0.2s..120s -->
        <div class="label">inhale (s)</div>
        <input id="tin"  type="range" min="0" max="1" step="0.001" value="0.35">
        <div id="tinVal" class="val">3.0</div>

        <div class="label">exhale (s)</div>
        <input id="tout" type="range" min="0" max="1" step="0.001" value="0.70">
        <div id="toutVal" class="val">7.0</div>

        <div class="label">gain high</div>
        <input id="ghi"  type="range" min="0.00" max="20" step="0.01" value="7.77">
        <div id="ghiVal" class="val">7.77</div>

        <div class="label">gain low</div>
        <input id="glo"  type="range" min="0.00" max="10" step="0.01" value="0.33">
        <div id="gloVal" class="val">0.33</div>

        <div class="row">
          <label style="display:flex;align-items:center;gap:8px;">
            <input id="rationalChk" type="checkbox" />
            rational breathing
          </label>
          <div id="ratInfo"></div>
        </div>

        <div class="label">units (0–57)</div>
        <input id="rationalUnits" type="range" min="0" max="57" step="1" value="0" disabled>
        <div id="rationalVal" class="val">0</div>
      </div>
    </details>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 0, 3);

/* ================== LIGHT (hollow disk, transparent core, dalga sarısı) ================== */
const ringGroup = new THREE.Group();
scene.add(ringGroup);

const planeGeo = new THREE.PlaneGeometry(2.6, 2.6, 1, 1);
const RING_COLOR = '#FFD75A';

const ringMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uRadius: { value: 0.42 },
    uWidth:  { value: 2.5 },
    uGain:   { value: 1.0 },
    uBrightness:{ value: 1.0 },
    uColor:  { value: new THREE.Color(RING_COLOR) },
  },
  vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader: `
    precision highp float; varying vec2 vUv;
    uniform float uTime,uRadius,uWidth,uGain,uBrightness; uniform vec3 uColor;
    void main(){
      vec2 p = vUv - 0.5; float r = length(p) * 2.0;

      // İnce halo bandı (annulus), içi tamamen boş (transparan)
      float innerEdge = 1.0 - smoothstep(uRadius - (1.0/uWidth), uRadius, r);
      float outerEdge = smoothstep(uRadius, uRadius + (0.8/uWidth), r);
      float band = innerEdge * (1.0 - outerEdge);

      // Dış alanı kes — yalnızca band
      float a = band * uGain * clamp(uBrightness,0.0,1.0);
      a = clamp(a, 0.0, 1.0);

      vec3 col = uColor * (0.95 + 0.05*sin(uTime*2.0));
      gl_FragColor = vec4(col*a, a);
      if (gl_FragColor.a < 0.001) discard;
    }
  `
});
const ringMesh = new THREE.Mesh(planeGeo, ringMat);
ringMesh.renderOrder = 2;
ringGroup.add(ringMesh);

/* ================== ORBITERS (rasgele yörüngeler; nefesle hız/genlik değişir) ================== */
let orbiters, orbitParams = [];
const ORBIT_COLOR = new THREE.Color(RING_COLOR);

function createOrbiters(N){
  if (orbiters) {
    ringGroup.remove(orbiters);
    orbiters.geometry.dispose();
    orbiters.material.dispose();
  }
  orbitParams = [];
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(N * 3);
  const colors = new Float32Array(N * 3);
  const sizes  = new Float32Array(N);

  for (let i=0;i<N;i++){
    // Her parçacık için: düzlem eğimi (küçük), başlangıç fazı, yarıçap, baz hız
    const tiltX = (Math.random()-0.5) * 0.45;   // az eğim → 2B hissi korunur
    const tiltY = (Math.random()-0.5) * 0.45;
    const phase = Math.random() * Math.PI*2;
    const radius= 0.42 + (Math.random()-0.5) * 0.03;  // ring çevresinde
    const baseW = 0.3 + Math.random()*0.6;            // baz açısal hız (rad/sn)
    orbitParams.push({ tiltX, tiltY, phase, radius, baseW });

    positions[i*3+0] = 0;
    positions[i*3+1] = 0;
    positions[i*3+2] = 0;

    colors[i*3+0] = ORBIT_COLOR.r;
    colors[i*3+1] = ORBIT_COLOR.g;
    colors[i*3+2] = ORBIT_COLOR.b;

    sizes[i] = 3.0 + Math.random()*2.0;  // px
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color',    new THREE.BufferAttribute(colors, 3));
  geo.setAttribute('size',     new THREE.BufferAttribute(sizes, 1));

  const mat = new THREE.ShaderMaterial({
    transparent: true, depthWrite: false, vertexColors: true,
    blending: THREE.AdditiveBlending,
    uniforms: { uPixelRatio:{ value: Math.min(devicePixelRatio, 2) }, uGain:{ value: 1.0 } },
    vertexShader: `
      attribute float size; varying vec3 vColor;
      uniform float uPixelRatio;
      void main(){
        vColor = color;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * uPixelRatio * (300.0 / -gl_Position.z);
      }
    `,
    fragmentShader: `
      precision highp float; varying vec3 vColor; uniform float uGain;
      void main(){
        // yumuşak disk nokta (Gaussian)
        vec2 uv = gl_PointCoord * 2.0 - 1.0;
        float d = dot(uv,uv);
        float a = exp(-d*6.0) * clamp(0.3 + 0.7*min(uGain/8.0, 1.0), 0.3, 1.0);
        gl_FragColor = vec4(vColor * a, a);
      }
    `
  });

  orbiters = new THREE.Points(geo, mat);
  orbiters.renderOrder = 3;
  ringGroup.add(orbiters);
}
createOrbiters(parseInt(document.getElementById('orbitCount').value,10));

/* ================== İNTERAKSİYON (inertial trackball) ================== */
let yaw = 0, pitch = 0;         // rad
let yawVel = 0, pitchVel = 0;   // rad/s
let distance = 3;

let isDown=false, lastX=0, lastY=0, lastMoveT=performance.now();
const DRIVE=14.0, FRICTION=0.95, MAX_V=14.0;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function pointerXY(e){ if('clientX'in e) return [e.clientX,e.clientY]; if('touches'in e&&e.touches.length) return [e.touches[0].clientX,e.touches[0].clientY]; return [0,0]; }

canvas.addEventListener('pointerdown',(e)=>{ isDown=true; canvas.setPointerCapture(e.pointerId); [lastX,lastY]=pointerXY(e); lastMoveT=performance.now(); });
canvas.addEventListener('pointermove',(e)=>{
  if(!isDown) return;
  const [x,y]=pointerXY(e); const now=performance.now();
  let dt=(now-lastMoveT)/1000; if(dt<=0) dt=1/120;
  const dx=(x-lastX)/innerWidth, dy=(y-lastY)/innerHeight;
  lastX=x; lastY=y; lastMoveT=now;
  const k=Math.PI;
  const tYaw=clamp((-dx*k)/dt,-MAX_V,MAX_V);
  const tPit=clamp((-dy*k*0.7)/dt,-MAX_V,MAX_V);
  const a=1.0-Math.exp(-DRIVE*dt);
  yawVel+=(tYaw-yawVel)*a; pitchVel+=(tPit-pitchVel)*a;
});
canvas.addEventListener('pointerup',(e)=>{ isDown=false; canvas.releasePointerCapture(e.pointerId); });
addEventListener('wheel',(e)=>{ distance+=Math.sign(e.deltaY)*0.15; distance=clamp(distance,1.4,6.0); },{passive:true});
let pinchStart=0;
canvas.addEventListener('touchstart',(e)=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinchStart=Math.hypot(dx,dy);} },{passive:true});
canvas.addEventListener('touchmove',(e)=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const d=Math.hypot(dx,dy); const s=(pinchStart>0)?(pinchStart/d):1.0; distance=clamp(distance*s,1.4,6.0); pinchStart=d; } },{passive:true});

/* ================== KONTROLLER ================== */
const radiusEl=document.getElementById('radius');
const gainEl  =document.getElementById('gain');
const orbitCountEl=document.getElementById('orbitCount');

const radiusVal=document.getElementById('radiusVal');
const gainVal  =document.getElementById('gainVal');
const orbitCountVal=document.getElementById('orbitCountVal');

const tinEl   =document.getElementById('tin');   // 0..1 (log)
const toutEl  =document.getElementById('tout');  // 0..1 (log)
const ghiEl   =document.getElementById('ghi');
const gloEl   =document.getElementById('glo');

const tinVal  =document.getElementById('tinVal');
const toutVal =document.getElementById('toutVal');
const ghiVal  =document.getElementById('ghiVal');
const gloVal  =document.getElementById('gloVal');

const rationalChk   = document.getElementById('rationalChk');
const rationalUnits = document.getElementById('rationalUnits');
const rationalVal   = document.getElementById('rationalVal');
const ratInfo       = document.getElementById('ratInfo');

const S_MIN=0.2, S_MAX=120;
const logMap = (t)=> Math.exp( Math.log(S_MIN)*(1-t) + Math.log(S_MAX)*t );

function updUI(){
  radiusVal.textContent = (+radiusEl.value).toFixed(2);
  gainVal.textContent   = (+gainEl.value).toFixed(2);
  orbitCountVal.textContent = orbitCountEl.value;

  const inh=logMap(+tinEl.value), exh=logMap(+toutEl.value);
  tinVal.textContent  = inh.toFixed(inh<10?2:1);
  toutVal.textContent = exh.toFixed(exh<10?2:1);
  ghiVal.textContent  = (+ghiEl.value).toFixed(2);
  gloVal.textContent  = (+gloEl.value).toFixed(2);
  rationalVal.textContent = rationalUnits.value;
}
radiusEl.addEventListener('input',()=>{
  const r=parseFloat(radiusEl.value);
  ringMat.uniforms.uRadius.value = r;
  // orbitlerin yarıçap hedefi güncellenir (anlık olarak yumuşatarak gideceğiz)
  orbitParams.forEach(o=>o.radius = r + (Math.random()-0.5)*0.03);
  updUI();
});
gainEl.addEventListener('input', updUI);
orbitCountEl.addEventListener('change',()=>{ createOrbiters(parseInt(orbitCountEl.value,10)); updUI(); });

tinEl.addEventListener('input', updUI);
toutEl.addEventListener('input', updUI);
ghiEl.addEventListener('input', updUI);
gloEl.addEventListener('input', updUI);

/* Rational breathing 0–57 */
rationalChk.addEventListener('change', ()=>{
  const on = rationalChk.checked;
  rationalUnits.disabled = !on;
  tinEl.disabled = toutEl.disabled = on;
  updateRatInfo();
});
rationalUnits.addEventListener('input', ()=>{ rationalVal.textContent=rationalUnits.value; updateRatInfo(); });
function fmtSecs(x){ if(x>3600)return (x/3600).toFixed(1)+'h'; if(x>600)return (x/60).toFixed(1)+'m'; return x.toFixed(x<10?2:1)+'s'; }
function fibPair(n){ if(n<=0)return [0n,0n]; let a=0n,b=1n; for(let i=1;i<=n;i++){const t=a+b; a=b; b=t;} return [a,b]; }
function bigToNum(bi){ const MAX=1e12; const n=Number(bi); return !Number.isFinite(n)?MAX:Math.min(n,MAX); }
function updateRatInfo(){
  const n=parseInt(rationalUnits.value,10);
  if(!rationalChk.checked){ ratInfo.textContent=''; return; }
  if(n===0){ ratInfo.textContent='breathless (sabit)'; return; }
  const [Fi,Fj]=fibPair(n); const i=bigToNum(Fi), j=bigToNum(Fj);
  ratInfo.textContent = `N=${n} → inhale=${fmtSecs(i)} • exhale=${fmtSecs(j)}`;
}

/* ================== NEFES MOTORU ================== */
function breathGain(t, tinSec, toutSec, lo, hi){
  tinSec=Math.max(0.0,tinSec); toutSec=Math.max(0.0,toutSec);
  const T=tinSec+toutSec;
  if(T<1e-6) return (lo+hi)*0.5;
  const ph = t % T;
  if(ph < tinSec){ const u=ph/tinSec; return lo + (hi-lo)*u; }
  else { const u=(ph-tinSec)/toutSec; return hi + (lo-hi)*u; }
}

/* ================== ANIMATE ================== */
const clock = new THREE.Clock();
function tick(){
  const t  = clock.getElapsedTime();
  const dt = clock.getDelta();

  // Trackball sönümü + entegrasyon
  const decay=Math.exp(-0.95*dt);
  yawVel*=decay; pitchVel*=decay;
  yaw += yawVel*dt; pitch += pitchVel*dt;
  pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));

  ringGroup.rotation.set(pitch, yaw, 0);
  camera.position.set(0, 0, distance);
  camera.lookAt(0, 0, 0);

  // Nefes (rational varsa override)
  let tinSec = logMap(+tinEl.value);
  let toutSec= logMap(+toutEl.value);
  if (rationalChk.checked){
    const n = parseInt(rationalUnits.value,10);
    if (n===0){ tinSec=0; toutSec=0; }
    else { const [Fi,Fj]=fibPair(n); tinSec=bigToNum(Fi); toutSec=bigToNum(Fj); }
  }
  const lo=parseFloat(gloEl.value), hi=parseFloat(ghiEl.value), gMul=parseFloat(gainEl.value);
  const gBreath = breathGain(t, tinSec, toutSec, lo, hi);
  const g = gBreath * gMul;

  // Işık
  ringMat.uniforms.uGain.value = g;
  ringMat.uniforms.uBrightness.value = 1.0 + 0.02*Math.sin(t*0.6);
  ringMat.uniforms.uTime.value = t;

  // Orbiters — nefese göre hız/genlik
  if (orbiters){
    const pos = orbiters.geometry.attributes.position.array;
    const N = orbitParams.length;
    // Gain ile hız skalası (log benzeri)
    const speedScale = 0.4 + Math.min(Math.log(1.0 + g) * 0.7, 2.0);
    // Gain ile hafif radial dalga
    const radJitter = 0.005 + Math.min(0.02, 0.004 * g);

    for (let i=0;i<N;i++){
      const o = orbitParams[i];
      const w = o.baseW * speedScale;         // açısal hız
      const th = o.phase + t * w;             // açı
      const r0 = o.radius + Math.sin(th*2.0 + i*0.37) * radJitter;

      // düzlem eğimini uygula (küçük tiltX/tiltY → 2B + derinlik hissi)
      let x = Math.cos(th) * r0;
      let y = Math.sin(th) * r0;
      let z = 0.0;

      // TiltY (around Y) ve TiltX (around X):
      // Y: x-z düzlemi
      const x1 =  x*Math.cos(o.tiltY) + z*Math.sin(o.tiltY);
      const z1 = -x*Math.sin(o.tiltY) + z*Math.cos(o.tiltY);
      // X: y-z düzlemi
      const y2 =  y*Math.cos(o.tiltX) - z1*Math.sin(o.tiltX);
      const z2 =  y*Math.sin(o.tiltX) + z1*Math.cos(o.tiltX);

      // dünya uzayında ringGroup döneceği için burada düzlemi sade bıraktık.
      pos[i*3+0] = x1 * 1.3; // plane daha büyük olduğundan ölçek
      pos[i*3+1] = y2 * 1.3;
      pos[i*3+2] = -0.001 + z2*0.08; // hafif z farkı (önde/arkada parlaklık shader’da)
    }
    orbiters.geometry.attributes.position.needsUpdate = true;
    orbiters.material.uniforms.uGain.value = g;

    // öndeki/arkadaki noktalar: additive ile zaten öndekiler daha parlak; ekstra bir şey gerekmiyor.
  }

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

/* Resize */
addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });

/* Başlangıç: başlıklar kapalı ve UI yazıları */
document.getElementById('shapeSec').open=false;
document.getElementById('breatheSec').open=false;
(function initUI(){
  ringMat.uniforms.uRadius.value = parseFloat(radiusEl.value);
  updUI();
})();
</script>
</body>
</html>
